// 2025-10-04 12:53:21
// Feather ignore all
//======================================================================================================================
#region ~ INDEX ~
//======================================================================================================================
/*
                             ____       _ _              ____            _
                            |  _ \ ___ | | | ___ _ __   / ___| _   _ ___| |_ ___ _ __ ___
                            | |_) / _ \| | |/ _ \ '_ \  \___ \| | | / __| __/ _ \ '_ ` _ \
                            |  __/ (_) | | |  __/ | | |  ___) | |_| \__ \ ||  __/ | | | | |
                            |_|   \___/|_|_|\___|_| |_| |____/ \__, |___/\__\___|_| |_| |_|
                                                               |___/
*/
//======================================================================================================================

/*                                                                                                          Completed?

    USEFUL TOOLS:
        ~ Tome (Auto generate doc site via docsify): https://github.com/CataclysmicStudios/Tome

    TODO:                                                                                                       [ ]                                                                                                            
        
        ~ Feature list (v1.0):                                                                                  [ ]
            ~ Setup hot-reload script                                                                           [X]
            ~ Create default GM-editor particle system                                                          [X]
            ~ Particle builder API                                                                              [X]
            ~ Util functions for bursting and streaming particles                                               [X]
            ~ Generate particle types from hot-reload script                                                    [X]
            ~ Ability to adjust any part type property from hot-reload script                                   [X]
            ~ Generate particle systems from hot-reload script                                                  [X]
            ~ Ability to adjust any part system/emitter property from hot-reload script                         [X]
            ~ Generate particle types from templates                                                            [ ]
            ~ Generate particle systems from templates (GM part assets, pollen systems, more?)                  [X]
            ~ Allow GM types/systems/part_assets to stream/burst using Pollen functions                         [ ]
            ~ Ensure easy cleanup of data (add .Destroy methods and check for mem-leaks)                        [ ]
            ~ Add error checks and basic debug tools                                                            [ ]
                ~ Error check burst/stream functions for tags that do not exist                                 [ ]
            ~ Add additional util functions                                                                     [ ]
            
        ~ Testing & polish:                                                                                     [ ]
            ~ Check builder functions to make sure all of them return self                                      [ ]
            ~ Ensure new types can be defined in emitter JSON (i.e. you can set "type" property as a struct)    [ ]
            ~ Add tests to ensure JSON data is valid                                                            [ ]
                ~ Refactor import functions to use struct_get_games to test for invalid JSON members            [X]
            ~ Add options to use structs or split-up variables for position, offset, size, etc?                 [ ]
                -> e.g. can do "size: {w: 64, h: 64}" OR "width: 64, height: 64"
            ~ Make functional on Gamemaker LTS version?                                                         [ ]
            ~ Test speed of calling stream/burst compared to regular GML backend                                [ ]
            ~ Code cleanup and documentation                                                                    [ ]
            
    DOCUMENTATION:
    
        ~ Alternate libraries:
            ~ https://github.com/GamemakerCasts/particles - A lightweight particle wrapper for GM
            ~ https://delfos1.itch.io/pulse - A custom particle emitter library that extends GM's capabilities
            
        ~ FAQ:
        
            ~ When compiling in YYC, users have to uncheck "automatically remove unused assets" when using 
              particle asset templates
              
            ~ Each particle type & system struct takes up roughly 0.1 - 0.3[+] mb, so it may be easiest to simply keep
              them in the global JSON rather than trying to manually create/destroy them, even if you only need them
              for specific levels/modes in your game (however, having an immense amount of emitters on one system will
              effect how much memory that system will take up, but even then, I don't think it's a huge concern).
             
        
        
    POTENTIAL FUTURE FEATURES:    
    
        ~ A particle editor tool that copies data as either gml or pollen-struct                            
        ~ Ability to use paths/curves to modify properties                                                  
        ~ Custom emitters:                                                                             
            ~ Utilize GPU for optimization and so shaders can be applied                
            ~ Customize shape of emitter using stencils
            ~ Emit particles along a path or using animation curves
            ~ Displacement maps to effect particle properties
            ~ Ability to cache emitter states for improved performance
            ~ Apply collision & forces to particles for more in-game interactions
            ~ Custom blendmodes for particles (metaball rendering for splatter fx)                                                          
            ~ Custom particle properties (blend shapes so a star can morph into a square for example?)                                  
            
            
*/

function Pollen() constructor {
    
    //There should be no more than one instance of Pollen
    static __numPollen = 0;
    __numPollen++;
    if(__numPollen > 1){Error("Only one instance of Pollen should ever be created which should be created automatically at the end of the Pollen() constructor.\n   There's no need to create more than one instance since Pollen only uses static vars.");}
    

#endregion    
//======================================================================================================================
#region ~ UPDATE ~
//======================================================================================================================

    //Set up an update function that executes one every frame forever.
    
    static __bootSetupTimer = 0;
    static __bootSetupPath = (POLLEN_LIVE_EDIT) ? filename_dir(GM_project_filename) + "/scripts/scr_pollen_config_pfx/scr_pollen_config_pfx.gml" : undefined;
    static __bootSetupHash = undefined;
    
    time_source_start(time_source_create(time_source_global, 1, time_source_units_frames, function()
    {
        
        if (POLLEN_LIVE_EDIT && ((os_type == os_windows) || (os_type == os_macosx) || (os_type == os_linux))){
            Pollen.__bootSetupTimer--;
            if (Pollen.__bootSetupTimer <= 0){
                Pollen.__bootSetupTimer = 60;
                
                var _newHash = md5_file(Pollen.__bootSetupPath);
                if (_newHash != Pollen.__bootSetupHash){
                    if (Pollen.__bootSetupHash == undefined){Pollen.__bootSetupHash = _newHash;}
                    else {
                        Pollen.__bootSetupHash = _newHash;
                        
                        var _buffer = buffer_load(Pollen.__bootSetupPath);
                        
                        var _gml = undefined;
                        try {
                            var _gml = __PollenBufferReadGML(_buffer, 0, buffer_get_size(_buffer));
                        }
                        catch(_error) {
                            show_debug_message(json_stringify(_error, true));
                            Warn("Failed to read GML");
                        }
                        
                        if (buffer_exists(_buffer)){
                            buffer_delete(_buffer);
                        }
                        
                        if (is_struct(_gml)){
                            try {
                                var _result = _gml[$ "global.pollen_config_pfx"] ?? [];
                                ImportPfx(_result);
                                global.pollen_config_pfx = _result;
                                // Log($"Success! Result = {_result[0]}");
                                // VinylSetupImportJSON(_gml[$ "global.VinylConfigSON"] ?? []);
                                // __VinylTrace("Successfully loaded config JSON from disk (", date_datetime_string(date_current_datetime()), ")");
                            }
                            catch(_error){
                                show_debug_message(json_stringify(_error, true));
                                Warn("Failed to import JSON");
                            }
                        }
                    }
                }
            }
        }
    }, [], -1));
    
 
#endregion   
//======================================================================================================================
#region ~ TYPES ~
//======================================================================================================================
    
    enum pollen_type_property {shape, sprite, size, scale, speed, direction, gravity, orientation, color, blend, life, step, death}
    
    static __typeMap = ds_map_create();
    static TypeTagGetData = function(_tag){return __typeMap[? _tag];}
    
    static PfxType = function(_tag) constructor {
        
        //--- SETUP BACKEND ---//
        if(Pollen.__typeMap[? _tag] != undefined){Pollen.Error($"Attempting to create pollen part type, but type tag: '{_tag}' already exists!");}
        Pollen.__typeMap[? _tag] = self; 
        
        //--- GML TYPE ---//
        __tag = _tag;
        __gmlData = part_type_create();
        static GetTag = function(){return __tag;}
        static GetGmlData = function(){return __gmlData;}
        
        //--- SHAPE ---//
        __shape = undefined;
        static GetShape = function(){return __shape;}
        static SetShape = function(_shape){
            __sprite.id = undefined; 
            __shape = _shape; 
            part_type_shape(__gmlData, _shape); 
            return self;
        }
        
        //--- SPRITE ---//
        __sprite = {id: undefined, subImg: 0, animate: false, stretch: false, randomImg: false}
        static GetSpriteData = function(){return __sprite;}
        static SetSprite = function(_sprite, _subImg = 0, _animate = false, _stretch = false, _randomImg = false){
            __shape = undefined; 
            __sprite = {id: _sprite, subImg: _subImg, animate: _animate, stretch: _stretch, randomImg: _randomImg}; 
            part_type_sprite(__gmlData, _sprite, _animate, _stretch, _randomImg); 
            part_type_subimage(__gmlData, _subImg);
            return self;
        }
        
        //--- SIZE ---// 
        __size = {min: 0, max: 0, incr: 0, wiggle: 0}
        __sizeX = undefined; //<--- I hate this but oh well...
        __sizeY = undefined;
        static GetSize = function(){return __size;}
        static SetSize = function(_min = undefined, _max = undefined, _incr = undefined, _wiggle = undefined){
            if(__size != undefined){_min ??= __size.min; _max ??= __size.max; _incr ??= __size.incr; _wiggle ??= __size.wiggle;}
            else {_min ??= 0; _max ??= 0; _incr ??= 0; _wiggle ??= 0;}
            __size = {min: _min, max: _max, incr: _incr, wiggle: _wiggle}
            __sizeX = undefined;
            __sizeY = undefined;
            part_type_size(__gmlData, _min, _max, _incr, _wiggle); 
            return self;
        }
        static GetSizeX = function(){return __sizeX;}
        static SetSizeX = function(_min = undefined, _max = undefined, _incr = undefined, _wiggle = undefined){
            if(__sizeX != undefined){_min ??= __sizeX.min; _max ??= __sizeX.max; _incr ??= __sizeX.incr; _wiggle ??= __sizeX.wiggle;}
            else {_min ??= 0; _max ??= 0; _incr ??= 0; _wiggle ??= 0;}
            __sizeX = undefined;
            __sizeX = {min: _min, max: _max, incr: _incr, wiggle: _wiggle};
            part_type_size_offsetX(__gmlData, _min, _max, _incr, _wiggle); 
            return self;
        }
        static GetSizeY = function(){return __sizeY;}
        static SetSizeY = function(_min = undefined, _max = undefined, _incr = undefined, _wiggle = undefined){
            if(__sizeY != undefined){_min ??= __sizeY.min; _max ??= __sizeY.max; _incr ??= __sizeY.incr; _wiggle ??= __sizeY.wiggle;}
            else {_min ??= 0; _max ??= 0; _incr ??= 0; _wiggle ??= 0;}
            __size = undefined;
            __sizeY = {min: _min, max: _max, incr: _incr, wiggle: _wiggle};
            part_type_size_y(__gmlData, _min, _max, _incr, _wiggle); 
            return self;
        }
        
        //--- SCALE ---//
        __scale = {x: 1, y: 1};
        static GetScale = function(){return __scale;}
        static SetScale = function(_x = __scale.x, _y = __scale.y){
            __scale = {x: _x, y: _y};
            part_type_scale(__gmlData, _x, _y); 
            return self;
        }
        
        //--- SPEED ---//
        __speed = { min: 1, max: 1, incr: 0, wiggle: 0 };
        static GetSpeed = function(){ return __speed; }
        static SetSpeed = function(
            _min    = __speed.min,
            _max    = __speed.max,
            _incr   = __speed.incr,
            _wiggle = __speed.wiggle
        ){
            __speed = { min: _min, max: _max, incr: _incr, wiggle: _wiggle };
            part_type_speed(__gmlData, _min, _max, _incr, _wiggle);
            return self;
        }
        
        //--- DIRECTION ---//
        __direction = { min: 0, max: 0, incr: 0, wiggle: 0 };
        static GetDirection = function(){ return __direction; }
        static SetDirection = function(
            _min    = __direction.min,
            _max    = __direction.max,
            _incr   = __direction.incr,
            _wiggle = __direction.wiggle
        ){
            __direction = { min: _min, max: _max, incr: _incr, wiggle: _wiggle };
            part_type_direction(__gmlData, _min, _max, _incr, _wiggle);
            return self;
        }
        
        //--- GRAVITY ---//
        __gravity = { amount: 0, direction: 270 };
        static GetGravity = function(){ return __gravity; }
        static SetGravity = function(
            _amount    = __gravity.amount,
            _direction = __gravity.direction
        ){
            __gravity = { amount: _amount, direction: _direction };
            part_type_gravity(__gmlData, _amount, _direction);
            return self;
        }
        
        //--- ORIENTATION ---//
        __orientation = { min: 0, max: 0, incr: 0, wiggle: 0, relative: false };
        static GetOrientation = function(){ return __orientation; }
        static SetOrientation = function(
            _min      = __orientation.min,
            _max      = __orientation.max,
            _incr     = __orientation.incr,
            _wiggle   = __orientation.wiggle,
            _relative = __orientation.relative
        ){
            __orientation = { min: _min, max: _max, incr: _incr, wiggle: _wiggle, relative: _relative };
            part_type_orientation(__gmlData, _min, _max, _incr, _wiggle, _relative);
            return self;
        }
        
        //--- COLOR MIX ---//
        __colorMix = undefined;
        static GetColorMix = function(){return __colorMix;}
        static SetColorMix = function(_colors_or_array){
            var _array = _colors_or_array;
            if(argument_count > 1){_array = [argument0, argument1];}
            __colorMix = _array;
            __colorRgb = undefined;
            __colorHsv = undefined;
            __color = undefined;
            part_type_color_mix(__gmlData, _array[0], _array[1]);
            return self;
        }
        
        //--- COLOR RGB ---//
        __colorRgb = undefined;
        static GetColorRgb = function(){return __colorRgb;}
        static SetColorRgb = function(_rmin, _rmax, _gmin, _gmax, _bmin, _bmax){
            __colorMix = undefined;
            __colorRgb = {rmin: _rmin, rmax: _rmax, gmin: _gmin, gmax: _gmax, bmin: _bmin, bmax: _bmax};
            __colorHsv = undefined;
            __color = undefined;
            part_type_color_rgb(__gmlData, _rmin, _rmax, _gmin, _gmax, _bmin, _bmax);
            return self;
        }
        
        //--- COLOR HSV ---//
        __colorHsv = undefined;
        static GetColorHsv = function(){return __colorHsv;}
        static SetColorHsv = function(_hmin, _hmax, _smin, _smax, _vmin, _vmax){
            __colorMix = undefined;
            __colorRgb = undefined;
            __colorHsv = {hmin: _hmin, hmax: _hmax, smin: _smin, smax: _smax, vmin: _vmin, vmax: _vmax};
            __color = undefined;
            part_type_color_hsv(__gmlData, _hmin, _hmax, _smin, _smax, _vmin, _vmax);
            return self;
        }
        
        //--- COLOR (STANDARD) ---//
        __color = c_white;
        static GetColor = function(){return __color;}
        static SetColor = function(_color_or_array){
            if(!is_array(_color_or_array)){
                __color = _color_or_array;
                part_type_color1(__gmlData, _color_or_array);
                __colorMix = undefined;
                __colorRgb = undefined;
                __colorHsv = undefined;
                return self;
            }
            var _numColors = array_length(_color_or_array);
            if(_numColors == 0){
                Pollen.Warn($"Attempting to set color of type: '{__tag}' using an empty array! Bailing!");
                return self;
            }
            else if(_numColors == 1){
                __color = _color_or_array[0];
                part_type_color1(__gmlData, _color_or_array[0]);
            }
            else if(_numColors == 2){
                __color = _color_or_array;
                part_type_color2(__gmlData, _color_or_array[0], _color_or_array[1]);
            }
            else if(_numColors == 3){
                __color = _color_or_array;
                part_type_color3(__gmlData, _color_or_array[0], _color_or_array[1], _color_or_array[2]);
            }
            else {
                Pollen.Warn($"Attempting to set color of type: '{__tag}' using an array larger than 3. Defaulting to first 3 values!");
                __color = [_color_or_array[0], _color_or_array[1], _color_or_array[2]];
                part_type_color3(__gmlData, _color_or_array[0], _color_or_array[1], _color_or_array[2]);
            }
            __colorMix = undefined;
            __colorRgb = undefined;
            __colorHsv = undefined;
            return self;
        }
        
        //--- ALPHA ---//
        __alpha = 1;
        static GetAlpha = function(){return __alpha;}
        static SetAlpha = function(_alpha_or_array){
            if(!is_array(_alpha_or_array)){
                __alpha = _alpha_or_array;
                part_type_alpha1(__gmlData, _alpha_or_array);
                return self;
            }
            var _numalphas = array_length(_alpha_or_array);
            if(_numalphas == 0){
                Pollen.Warn($"Attempting to set alpha of type: '{__tag}' using an empty array! Bailing!");
            }
            else if(_numalphas == 1){
                __alpha = _alpha_or_array[0];
                part_type_alpha1(__gmlData, _alpha_or_array[0]);
            }
            else if(_numalphas == 2){
                __alpha = _alpha_or_array;
                part_type_alpha2(__gmlData, _alpha_or_array[0], _alpha_or_array[1]);
            }
            else if(_numalphas == 3){
                __alpha = _alpha_or_array;
                part_type_alpha3(__gmlData, _alpha_or_array[0], _alpha_or_array[1], _alpha_or_array[2]);
            }
            else {
                Pollen.Warn($"Attempting to set alpha of type: '{__tag}' using an array larger than 3. Defaulting to first 3 values!");
                __alpha = [_alpha_or_array[0], _alpha_or_array[1], _alpha_or_array[2]];
                part_type_alpha3(__gmlData, _alpha_or_array[0], _alpha_or_array[1], _alpha_or_array[2]);
            }
            return self;
        }
        
        //--- BLEND ---//
        __blend = false;
        static GetBlend = function(){return __blend;}
        static SetBlend = function(_blend){
            __blend = _blend; 
            part_type_blend(__gmlData, _blend); 
            return self;
        }
        
        //--- LIFE ---//
        __life = { min: 100, max: 100};
        static GetLife = function(){ return __life; }
        static SetLife = function(_min = __life.min, _max = __life.max){
            __life = { min: _min, max: _max };
            part_type_life(__gmlData, _min, _max);
            return self;
        }
        
        //--- SUB-PARTICLE STEP ---//
        __step = { number: 0, type: undefined};
        static GetStep = function(){ return __step; }
        static SetStep = function(_number = __step.number, _type = __step.type){
            __step = { number: _number, type: _type };
            if(is_string(_type)){
                var _mapData = Pollen.__typeMap[? _type];
                if(_mapData == undefined){Pollen.Error($"Particle type '{_type}' is not defined in particle map!");}
                _type = _mapData.GetGmlData();
            }
            part_type_step(__gmlData, _number, _type);
            return self;
        }
        
        //--- SUB-PARTICLE DEATH ---//
        __death = { number: 0, type: undefined};
        static GetDeath = function(){ return __death; }
        static SetDeath = function(_number = __death.number, _type = __death.type){
            __death = { number: _number, type: _type };
            if(is_string(_type)){
                var _mapData = Pollen.__typeMap[? _type];
                if(_mapData == undefined){Pollen.Error($"Particle type '{_type}' is not defined in particle map!");}
                _type = _mapData.GetGmlData();
            }
            part_type_death(__gmlData, _number, _type);
            return self;
        }

        static Copy = function(_target){
            if(_target == undefined || _target == self){return;}

            var _sprite = GetSpriteData();
            var _shape = GetShape();
            if(_sprite != undefined && _sprite.id != undefined){
                _target.SetSprite(
                    _sprite.id,
                    _sprite.subImg,
                    _sprite.animate,
                    _sprite.stretch,
                    _sprite.randomImg
                );
            }
            else if(_shape != undefined){
                _target.SetShape(_shape);
            }

            var _size = GetSize();
            if(_size != undefined){
                _target.SetSize(_size.min, _size.max, _size.incr, _size.wiggle);
            }

            var _sizeX = GetSizeX();
            if(_sizeX != undefined){
                _target.SetSizeX(_sizeX.min, _sizeX.max, _sizeX.incr, _sizeX.wiggle);
            }

            var _sizeY = GetSizeY();
            if(_sizeY != undefined){
                _target.SetSizeY(_sizeY.min, _sizeY.max, _sizeY.incr, _sizeY.wiggle);
            }

            var _scale = GetScale();
            if(_scale != undefined){
                _target.SetScale(_scale.x, _scale.y);
            }

            var _speed = GetSpeed();
            if(_speed != undefined){
                _target.SetSpeed(_speed.min, _speed.max, _speed.incr, _speed.wiggle);
            }

            var _direction = GetDirection();
            if(_direction != undefined){
                _target.SetDirection(_direction.min, _direction.max, _direction.incr, _direction.wiggle);
            }

            var _gravity = GetGravity();
            if(_gravity != undefined){
                _target.SetGravity(_gravity.amount, _gravity.direction);
            }

            var _orientation = GetOrientation();
            if(_orientation != undefined){
                _target.SetOrientation(
                    _orientation.min,
                    _orientation.max,
                    _orientation.incr,
                    _orientation.wiggle,
                    _orientation.relative
                );
            }

            var _colorMix = GetColorMix();
            if(_colorMix != undefined){
                _target.SetColorMix(_colorMix);
            }
            else{
                var _colorRgb = GetColorRgb();
                if(_colorRgb != undefined){
                    _target.SetColorRgb(
                        _colorRgb.rmin,
                        _colorRgb.rmax,
                        _colorRgb.gmin,
                        _colorRgb.gmax,
                        _colorRgb.bmin,
                        _colorRgb.bmax
                    );
                }
                else{
                    var _colorHsv = GetColorHsv();
                    if(_colorHsv != undefined){
                        _target.SetColorHsv(
                            _colorHsv.hmin,
                            _colorHsv.hmax,
                            _colorHsv.smin,
                            _colorHsv.smax,
                            _colorHsv.vmin,
                            _colorHsv.vmax
                        );
                    }
                    else{
                        var _color = GetColor();
                        if(_color != undefined){
                            _target.SetColor(_color);
                        }
                    }
                }
            }

            var _alpha = GetAlpha();
            if(_alpha != undefined){
                _target.SetAlpha(_alpha);
            }

            var _blend = GetBlend();
            if(_blend != undefined){
                _target.SetBlend(_blend);
            }

            var _life = GetLife();
            if(_life != undefined){
                _target.SetLife(_life.min, _life.max);
            }

            var _step = GetStep();
            if(_step.type != undefined){
                _target.SetStep(_step.number, _step.type);
            }

            var _death = GetDeath();
            if(_death.type != undefined){
                _target.SetDeath(_death.number, _death.type);
            }
        }
        
    }


#endregion 
//======================================================================================================================
#region ~ EMITTERS ~
//======================================================================================================================

    // static __emitterMap = ds_map_create();
    // static EmitterTagGetData = function(_tag){return __emitterMap[? _tag];}
    
    //NOTE: Emitters must be tied to systems which is why I'm defining the data inside Pfx instead of Pollen
    static PfxEmitter = function(_system) constructor {
        
        //--- SETUP PROPERTIES ---//
        __gmlData = part_emitter_create(_system.GetGmlData());
        __system = _system;
        __enabled = true;
        __type = undefined;
        __number = 1;
        __shape = ps_shape_ellipse;
        __distr = ps_distr_linear;
        __relative = false;
        __delay = {min: 0, max: 0, unit: time_source_units_frames};
        __interval = {min: 0, max: 0, unit: time_source_units_frames};
        __width = 0;
        __height = 0;
        __offsetX = 0;
        __offsetY = 0;
        
        //--- SETTERS ---//
        static SetEnabled = function(_enabled){__enabled = _enabled; return self;}
        static SetType = function(_type){__type = _type; __system.RefreshStream(); return self;}
        static SetNumber = function(_number){__number = _number; __system.RefreshStream(); return self;}
        static SetShape = function(_shape){__shape = _shape; __system.RefreshStream(); return self;}
        static SetDistr = function(_distr){__distr = _distr; __system.RefreshStream(); return self;}
        
        static SetRelative = function(_enabled){
            __relative = _enabled; 
            part_emitter_relative(__system.GetGmlData(), __gmlData, _enabled);
            __system.RefreshStream(); 
            return self;
        }
        static SetDelay = function(_delay){
            __delay = _delay; 
            part_emitter_delay(__system.GetGmlData(), __gmlData, _delay.min, _delay.max, _delay.unit);
            __system.RefreshStream(); 
            return self;
        }
        static SetInterval = function(_interval){
            __interval = _interval; 
            part_emitter_interval(__system.GetGmlData(), __gmlData, _interval.min, _interval.max, _interval.unit);
            __system.RefreshStream(); 
            return self;
        }
        
        static SetSize = function(_width, _height){
            __width = _width; 
            __height = _height; 
            __system.RefreshStream();
            return self;
        }
        static SetWidth = function(_width){SetSize(_width, __height); return self;}
        static SetHeight = function(_height){SetSize(__width, _height); return self;}
        
        static SetOffset = function(_offsetX, _offsetY){
            __offsetX = _offsetX;
            __offsetY = _offsetY;
            __system.RefreshStream();
            return self;
        }
        static SetOffsetX = function(_offsetX){SetOffset(_offsetX, __offsetY); return self;}
        static SetOffsetY = function(_offsetY){SetOffset(__offsetX, _offsetY); return self;}
        
        //--- GETTERS ---//
        static GetGmlData = function(){return __gmlData;}
        static GetSystem = function(){return __system;}
        static IsEnabled = function(){return __enabled;}
        static GetEnabled = function(){return __enabled;}
        static GetType = function(){return __type;}
        static GetNumber = function(){return __number;}
        static GetShape = function(){return __shape;}
        static GetDistr = function(){return __distr;}
        static GetRelative = function(){return __relative;}
        static GetDelay = function(){return __delay;}
        static GetInterval = function(){return __interval;}
        static GetSize = function(){return {w: __width, h: __height}}
        static GetWidth = function(){return __width;}
        static GetHeight = function(){return __height;}
        static GetOffset = function(){return {x: __offsetX, y: __offsetY}}
        static GetOffsetX = function(){return __offsetX;}
        static GetOffsetY = function(){return __offsetY;}
    }
    
    static EmitterDestroy = function(_pfxEmitter){
        var _system = _pfxEmitter.GetSystem();
        part_emitter_destroy(_system.GetGmlData(), _pfxEmitter.GetGmlData());
        delete _pfxEmitter;
        Log($"Destroyed emitter from {_system.GetTag()}");
    }
   
  
#endregion 
//======================================================================================================================
#region ~ SYSTEMS ~
//======================================================================================================================

    static __systemMap = ds_map_create();
    static SystemTagGetData = function(_tag){return __systemMap[? _tag];}

    static Pfx = function(_tag, _system = undefined, _typeList = undefined, _emitterList = undefined) constructor {
        
        //--- SETUP BACKEND ---//
        if(Pollen.__systemMap[? _tag] != undefined){Pollen.Error($"Attempting to create pollen part system, but system tag: '{_tag}' already exists!");}
        Pollen.__systemMap[? _tag] = self; 
        
        
        //--- SETUP PROPERTIES ---//
        __tag = _tag;
        __gmlData = _system ?? part_system_create();
        __template = undefined;
        __position = {x: 0, y: 0}
        __globalSpace = false;
        __drawOrder = true;
        __angle = 0;
        __depth = 0;
        __layer = undefined;
        __color = c_white;
        __alpha = 1;
        __typeList = _typeList ?? [];
        __emitterList = _emitterList ?? [];
        __isStreaming = false;
        __streamNumber = undefined;
        
        
        //--- SETTERS ---//
        // static SetPosition = function(_x, _y){__position = {x: _x, y: _y}; return self;}
        static SetTypeList = function(_list){__typeList = _list; return self;}
        static SetEmitterList = function(_list){__emitterList = _list; return self;}
        static SetColor = function(_color){
            __color = _color; 
            part_system_color(__gmlData, _color, __alpha); 
            RefreshStream();
            return self;
        }
        static SetAlpha = function(_alpha){
            __alpha = _alpha; 
            part_system_color(__gmlData, __color, _alpha); 
            RefreshStream();
            return self;
        }
        static SetPosition = function(_x = undefined, _y = undefined){
            __position.x = _x ?? __position.x;
            __position.y = _y ?? __position.y;
            part_system_position(__gmlData, __position.x, __position.y);
            // RefreshStream(); //<---NOTE: This will cause a freeze since there is a recursive loop since PfxStream also calls the SetPosition() method
            return self;
        }
        static SetGlobalSpace = function(_enabled){
            __globalSpace = _enabled;
            part_system_global_space(__gmlData, _enabled);
            return self;
        }
        static SetDrawOrder = function(_enabled){
            __drawOrder = _enabled;
            part_system_draw_order(__gmlData, _enabled);
            return self;
        }
        static SetAngle = function(_angle){
            __angle = _angle;
            part_system_angle(__gmlData, _angle);
            // RefreshStream(); //<---NOTE: This is not needed for part_system_angle
            return self;
        }
        static SetDepth = function(_depth){
            if(_depth == undefined){return;}
            __depth = _depth; 
            __layer = undefined;
            part_system_depth(__gmlData, _depth); 
            RefreshStream(); 
            return self;
        }
        static SetLayer = function(_layer){
            if(_layer == undefined){return;}
            var _id = layer_get_id(_layer);
            if(_id == -1){Pollen.Error("layer: '{_layer}' does not exist in current room!");}
            __layer = _layer;
            __depth = layer_get_depth(_id);
            part_system_layer(__gmlData, _id);
            return self;
        }
        
        static SetTypeProperty = function(_index_or_tag, _property, _args){
            if(!is_real(_index_or_tag)){return self;}
            var _type = __typeList[_index_or_tag];
            Pollen.TypeSetProperty(_type, _property, _args);
            return self;
        }
        
        //--- GETTERS ---//
        static GetTag = function(){return __tag;}
        static GetGmlData = function(){return __gmlData;}
        static GetTemplate = function(){return __template;}
        static GetDepth = function(){return __depth;}
        static GetLayer = function(){return __layer;}
        static GetPosition = function(){return __position;}
        static GetGlobalSpace = function(){return __globalSpace;}
        static GetDrawOrder = function(){return __drawOrder;}
        static GetAngle = function(){return __angle;}
        static GetColor = function(){return __color;}
        static GetAlpha = function(){return __alpha;}
        static GetTypeList = function(){return __typeList;}
        static GetEmitterList = function(){return __emitterList;}
        
        //--- UTIL ---//
        static RefreshStream = function(){
            if(!__isStreaming){return;}
            var _numEmitter = array_length(__emitterList);
            var _i = -1;
            repeat(_numEmitter){
                _i++;
                var _emitter = __emitterList[_i];
                var _emitterGml = _emitter.GetGmlData();
                part_emitter_clear(__gmlData, _emitterGml);
                
                //These have to be reset every refresh as well
                var _emitterDelay = _emitter.GetDelay();
                var _emitterInterval = _emitter.GetInterval();
                var _emitterRelative = _emitter.GetRelative();
                part_emitter_delay(__gmlData, _emitterGml, _emitterDelay.min, _emitterDelay.max, _emitterDelay.unit);
                part_emitter_interval(__gmlData, _emitterGml, _emitterInterval.min, _emitterInterval.max, _emitterInterval.unit);
                part_emitter_relative(__gmlData, _emitterGml, _emitterRelative);
            }
            Pollen.PfxStream(__tag);
        }
        
        static Copy = function(_pfx, _ignore_emitter_list = false) {
            SetPosition(_pfx.__position.x, _pfx.__position.y);
            SetGlobalSpace(_pfx.__globalSpace);
            SetDrawOrder(_pfx.__drawOrder);
            SetAngle(_pfx.__angle);
            SetDepth(_pfx.__depth);
            SetLayer(_pfx.__layer);
            SetColor(_pfx.__color);
            SetAlpha(_pfx.__alpha);
            
            if(!_ignore_emitter_list){
                var _emitterList = _pfx.__emitterList;
                var _numEmitters = array_length(_emitterList);
                var _copyList = [];
                var _iEm = -1;
                repeat(_numEmitters){
                    _iEm++;
                    var _emitter = _emitterList[_iEm];
                    var _newEm = new Pollen.PfxEmitter(self)
                        .SetEnabled(_emitter.IsEnabled())
                        .SetWidth(_emitter.GetWidth())
                        .SetHeight(_emitter.GetHeight())
                        .SetNumber(_emitter.GetNumber())
                        .SetType(_emitter.GetType())
                        .SetShape(_emitter.GetShape())
                        .SetDistr(_emitter.GetDistr())
                        .SetRelative(_emitter.GetRelative())
                        .SetDelay(_emitter.GetDelay())
                        .SetInterval(_emitter.GetInterval())
                        .SetOffsetX(_emitter.GetOffsetX())
                        .SetOffsetY(_emitter.GetOffsetY());
                    array_push(_copyList, _newEm);
                }
                SetEmitterList(_copyList);
            }
            
            Pollen.Log($"Successfully copied from system: {_pfx.GetTag()}");
        }
    }
    
    static PfxStream = function(_system_or_tag, _x = 0, _y = 0, _amount = undefined){
        if(is_string(_system_or_tag)){
            
            var _data = __systemMap[? _system_or_tag];
            var _gmlData = _data.GetGmlData();
            var _emitterList = _data.GetEmitterList();
            var _typeList = _data.GetTypeList();
            
            // var _oldPos = _data.GetPosition();
            // _x ??= _oldPos.x; _y ??= _oldPos.y;
            _data.__isStreaming = true;
            _data.__streamNumber = _amount;
            
            var _i = -1;
            var _numEmitters = array_length(_emitterList);
            repeat(_numEmitters){
                _i++;
                var _emitter = _emitterList[_i];
                if(!_emitter.IsEnabled()){continue;}
                var _emitterGml = _emitter.GetGmlData();
                
                var _number = _amount ?? _emitter.GetNumber(); //<---will give users the ability to set default values when I add emitter data later
                var _halfW = 0.5*_emitter.GetWidth(), _halfH = 0.5*_emitter.GetHeight();
                var _offsetX = _x + _emitter.GetOffsetX(), _offsetY = _y + _emitter.GetOffsetY();
                var _left = _offsetX - _halfW, _right = _offsetX + _halfW;
                var _top = _offsetY - _halfH, _bottom = _offsetY + _halfH;
                var _shape = _emitter.GetShape(), _distr = _emitter.GetDistr();
                
                var _type = _emitter.GetType();
                if(is_string(_type)){_type = TypeTagGetData(_type); _emitter.SetType(_type);}
                var _typeGml = _type.GetGmlData();
                
                part_emitter_region(_gmlData, _emitterGml, _left, _right, _top, _bottom, _shape, _distr);
                part_emitter_stream(_gmlData, _emitterGml, _typeGml, _number);
            }
        }
        //I'll add support for calling with raw Pollen.Pfx data, gml part systems & possibly gml part assets later
        return;
    }
    
    static PfxBurst = function(_system_or_tag, _x = 0, _y = 0, _amount = undefined){
        if(is_string(_system_or_tag)){
            
            var _data = __systemMap[? _system_or_tag];
            var _gmlData = _data.GetGmlData();
            var _emitterList = _data.GetEmitterList();
            var _typeList = _data.GetTypeList();
            
            // var _oldPos = _data.GetPosition();
            // _x ??= _oldPos.x; _y ??= _oldPos.y;
            
            var _i = -1;
            var _numEmitters = array_length(_emitterList);
            repeat(_numEmitters){
                _i++;
                var _emitter = _emitterList[_i];
                if(!_emitter.IsEnabled()){continue;}
                var _emitterGml = _emitter.GetGmlData();
                
                var _number = _amount ?? _emitter.GetNumber(); //<---will give users the ability to set default values when I add emitter data later
                var _halfW = 0.5*_emitter.GetWidth(), _halfH = 0.5*_emitter.GetHeight();
                var _offsetX = _x + _emitter.GetOffsetX(), _offsetY = _y + _emitter.GetOffsetY();
                var _left = _offsetX - _halfW, _right = _offsetX + _halfW;
                var _top = _offsetY - _halfH, _bottom = _offsetY + _halfH;
                var _shape = _emitter.GetShape(), _distr = _emitter.GetDistr();
                
                var _type = _emitter.GetType();
                if(is_string(_type)){_type = TypeTagGetData(_type); _emitter.SetType(_type);}
                var _typeGml = _type.GetGmlData();
                
                part_emitter_region(_gmlData, _emitterGml, _left, _right, _top, _bottom, _shape, _distr);
                part_emitter_burst(_gmlData, _emitterGml, _typeGml, abs(_number)); //<---Take abs since in stream mode a number can be set to negative so always default to the positive of that value when bursting
            }
        }
        //I'll add support for calling with raw Pollen.Pfx data, gml part systems & possibly gml part assets later
        return;
    }
    

#endregion   
//======================================================================================================================
#region ~ IMPORT ~
//======================================================================================================================
    
    static ImportPfx = function(_data){
        if(!is_array(_data)){Error("global.pollen_config_vfx must be an array!");}
        var _i = -1;
        var _len = array_length(_data);
        repeat(_len){
            _i++;
            var _struct = _data[_i];
            if(struct_exists(_struct, "type")){
                var _tag = struct_get(_struct, "type");
                var _tagData = TypeTagGetData(_tag);
                if(_tagData == undefined){_tagData = new PfxType(_tag);}
                ImportPfxType(_struct, _tagData);
                Log($"Type: '{_tag}' was reloaded.");
            }
            else if (struct_exists(_struct, "system")){
                var _tag = struct_get(_struct, "system");
                var _tagData = SystemTagGetData(_tag);
                if(_tagData == undefined){_tagData = new Pfx(_tag);}
                var _template = struct_get(_struct, "template");
                var _oldTemplate = _tagData.GetTemplate();
                if(_template!= undefined && _oldTemplate != _template){
                    var _ignoreEmitterList = struct_exists(_struct, "emitterList");
                    if(is_string(_template)){
                        var _templateID = SystemTagGetData(_template);
                        if(_templateID == undefined){Error($"Unable to find system: '{_template}' make sure system is defined before using it as a template!");}
                        _tagData.Copy(_templateID, _ignoreEmitterList);
                    }
                    else if(asset_get_index(_template) != -1){ConvertGmlPartAssetToPollenStruct(_template, _tagData, _ignoreEmitterList);}
                } 
                
                var _sysNames = struct_get_names(_struct);
                var _numSysNames = array_length(_sysNames);
                var _iSys = -1;
                repeat(_numSysNames){
                    _iSys++;
                    var _name = _sysNames[_iSys];
                    switch(_name){
                        case "system": break; //<---Not needed since it's handled above
                        case "template": break; //<---Not needed since it's handled above
                        case "depth": var _depth = _struct.depth; _tagData.SetDepth(_depth); break;
                        case "layer": var _layer = _struct.layer; _tagData.SetLayer(_layer); break;
                        case "angle": var _angle = _struct.angle; _tagData.SetAngle(_angle); break;
                        case "position": var _position = _struct.position; _tagData.SetPosition(_position); break;
                        case "globalSpace": var _globalSpace = _struct.globalSpace; _tagData.SetGlobalSpace(_globalSpace); break;
                        case "drawOrder": var _drawOrder = _struct.drawOrder; _tagData.SetDrawOrder(_drawOrder); break;
                        case "color": var _color = _struct.color; _tagData.SetColor(_color); break;
                        case "alpha": var _alpha = _struct.alpha; _tagData.SetDepth(_alpha); break;
                        case "emitterList":
                            var _emitterList = _struct.emitterList;
                            var _numOldList = array_length(_tagData.GetEmitterList());
                            var _numNewList = array_length(_emitterList);
                            var _numDiff = _numNewList - _numOldList;
                            
                            //Get rid of old emitters
                            if(_numDiff < 0){
                                var _iOld = 0;
                                repeat(abs(_numDiff)){
                                    _iOld++;
                                    var _deadEmit = _tagData.GetEmitterList()[_numOldList - _iOld];
                                    EmitterDestroy(_deadEmit);
                                    array_pop(_tagData.GetEmitterList());
                                }
                            }
                            
                            var _iEmList = -1;
                            repeat(_numNewList){
                                _iEmList++;
                                var _props = _emitterList[_iEmList];
                                var _emitter;
                                if(_numOldList >= _iEmList + 1){_emitter = _tagData.GetEmitterList()[_iEmList];}
                                else {_emitter = new PfxEmitter(_tagData); array_push(_tagData.GetEmitterList(), _emitter);}
                                
                                var _iEm = -1;
                                var _emNameList = struct_get_names(_props);
                                var _numEmNames = array_length(_emNameList);
                                repeat(_numEmNames){
                                    _iEm++;
                                    var _emName = _emNameList[_iEm];
                                    switch(_emName){
                                        case "type": var _type = _props.type; _emitter.SetType(_type); break;
                                        case "enabled": var _enabled = _props.enabled; _emitter.SetEnabled(_enabled); break;
                                        case "width": var _width = _props.width; _emitter.SetWidth(_width); break;
                                        case "height": var _height = _props.height; _emitter.SetHeight(_height); break;
                                        case "relative": var _relative = _props.relative; _emitter.SetRelative(_relative); break; 
                                        case "number": var _number = _props.number; _emitter.SetNumber(_number); break;
                                        case "shape": var _shape = _props.shape; _emitter.SetShape(_shape); break;
                                        case "distr": var _distr = _props.distr; _emitter.SetDistr(_distr); break;
                                        case "delay": var _delay = _props.delay; _emitter.SetDelay(_delay); break;
                                        case "interval": var _interval = _props.interval; _emitter.SetInterval(_interval); break;
                                        case "offsetX": var _offsetX = _props.offsetX; _emitter.SetOffsetX(_offsetX); break;
                                        case "offsetY": var _offsetY = _props.offsetY; _emitter.SetOffsetY(_offsetY); break;
                                        default: Log($"Emitter property {_emName} is not supported!");
                                    }
                                }
                            }
                            _tagData.RefreshStream();
                            break;
                        
                        default: Log($"System property: {_name} is not supported!");
                    }
                }
                Log($"System: '{_tag}' was reloaded.");
            }
            else {
                static __expectedList = "type', 'system'";
                Error($"Struct at global.pollen_config_pfx[{_i}] could not be parsed. Struct should contain one of the following properties: {__expectedList}");
            }
        }
    }
    
    static ImportPfxType = function(_import_data, _type_data){
        var _template = struct_get(_import_data, "template");
        if(_template != undefined){
            if(!is_string(_template)){
                Error($"Template defined for type '{_import_data.type}' must be a string!");
            }
            else{
                var _templateData = TypeTagGetData(_template);
                if(_templateData == undefined){
                    Error($"Unable to find template type '{_template}' while loading '{_import_data.type}'!");
                }
                else if(_templateData != _type_data){
                    _templateData.Copy(_type_data);
                }
            }
        }

        var _i = -1;
        var _nameList = struct_get_names(_import_data);
        var _numNames = array_length(_nameList);
        repeat(_numNames){
            _i++;
            var _name = _nameList[_i];
            switch(_name){

                case "type": break; //<---'type' is checked before ImportPfxType function is called.

                case "template": break;
                
                case "shape": var _shape = _import_data.shape; _type_data.SetShape(_shape); break;
                
                case "sprite":
                    var _sprite = _import_data.sprite;
                    var _id = struct_get(_sprite, "id");
                    if(_id == undefined){
                        Pollen.Error($"Sprite struct defined in '{_import_data.type}' must contain 'id' property!");
                    }
                    var _default   = _type_data.GetSpriteData();
                    var _subImg    = struct_get(_sprite, "subImg")    ?? _default.subImg;
                    var _animate   = struct_get(_sprite, "animate")   ?? _default.animate;
                    var _stretch   = struct_get(_sprite, "stretch")   ?? _default.stretch;
                    var _randomImg = struct_get(_sprite, "randomImg") ?? _default.randomImg;
                    _type_data.SetSprite(_id, _subImg, _animate, _stretch, _randomImg);
                    break;
                    
                case "size":
                    var _size = _import_data.size;
                    var _def = _type_data.GetSize();
                    if (_def == undefined) { _def = { min: 0, max: 0, incr: 0, wiggle: 0 }; }
                    var _min    = struct_get(_size, "min")    ?? _def.min;
                    var _max    = struct_get(_size, "max")    ?? _def.max;
                    var _incr   = struct_get(_size, "incr")   ?? _def.incr;
                    var _wiggle = struct_get(_size, "wiggle") ?? _def.wiggle;
                    _type_data.SetSize(_min, _max, _incr, _wiggle);
                    break;
                    
                case "sizeX":
                    var _sizeX = _import_data.sizeX;
                    var _defX = _type_data.GetSizeX();
                    if (_defX == undefined) { _defX = { min: 0, max: 0, incr: 0, wiggle: 0 }; }
                    var _minX    = struct_get(_sizeX, "min")    ?? _defX.min;
                    var _maxX    = struct_get(_sizeX, "max")    ?? _defX.max;
                    var _incrX   = struct_get(_sizeX, "incr")   ?? _defX.incr;
                    var _wiggleX = struct_get(_sizeX, "wiggle") ?? _defX.wiggle;
                    _type_data.SetSizeX(_minX, _maxX, _incrX, _wiggleX);
                    break;
                    
                case "sizeY":
                    var _sizeY = _import_data.sizeY;
                    var _defY = _type_data.GetSizeY();
                    if (_defY == undefined) { _defY = { min: 0, max: 0, incr: 0, wiggle: 0 }; }
                    var _minY    = struct_get(_sizeY, "min")    ?? _defY.min;
                    var _maxY    = struct_get(_sizeY, "max")    ?? _defY.max;
                    var _incrY   = struct_get(_sizeY, "incr")   ?? _defY.incr;
                    var _wiggleY = struct_get(_sizeY, "wiggle") ?? _defY.wiggle;
                    _type_data.SetSizeY(_minY, _maxY, _incrY, _wiggleY);
                    break;
                    
                case "scale":
                    var _scale = _import_data.scale;
                    var _defScale = _type_data.GetScale();
                    var _sx = struct_get(_scale, "x") ?? _defScale.x;
                    var _sy = struct_get(_scale, "y") ?? _defScale.y;
                    _type_data.SetScale(_sx, _sy);
                    break;
                    
                case "speed":
                    var _speed = _import_data.speed;
                    var _defSpeed = _type_data.GetSpeed();
                    var _smin    = struct_get(_speed, "min")    ?? _defSpeed.min;
                    var _smax    = struct_get(_speed, "max")    ?? _defSpeed.max;
                    var _sincr   = struct_get(_speed, "incr")   ?? _defSpeed.incr;
                    var _swiggle = struct_get(_speed, "wiggle") ?? _defSpeed.wiggle;
                    _type_data.SetSpeed(_smin, _smax, _sincr, _swiggle);
                    break;
                    
                case "direction":
                    var _direction = _import_data.direction;
                    var _defDir = _type_data.GetDirection();
                    var _dmin    = struct_get(_direction, "min")    ?? _defDir.min;
                    var _dmax    = struct_get(_direction, "max")    ?? _defDir.max;
                    var _dincr   = struct_get(_direction, "incr")   ?? _defDir.incr;
                    var _dwiggle = struct_get(_direction, "wiggle") ?? _defDir.wiggle;
                    _type_data.SetDirection(_dmin, _dmax, _dincr, _dwiggle);
                    break;
                    
                case "orientation":
                    var _orientation = _import_data.orientation;
                    var _defOri = _type_data.GetOrientation();
                    var _omin  = struct_get(_orientation, "min")      ?? _defOri.min;
                    var _omax  = struct_get(_orientation, "max")      ?? _defOri.max;
                    var _oinc  = struct_get(_orientation, "incr")     ?? _defOri.incr;
                    var _owig  = struct_get(_orientation, "wiggle")   ?? _defOri.wiggle;
                    var _orel  = struct_get(_orientation, "relative") ?? _defOri.relative;
                    _type_data.SetOrientation(_omin, _omax, _oinc, _owig, _orel);
                    break;
                    
                case "gravity":
                    var _gravity = _import_data.gravity;
                    var _defGrav = _type_data.GetGravity();
                    var _gamt = struct_get(_gravity, "amount")    ?? _defGrav.amount;
                    var _gdir = struct_get(_gravity, "direction") ?? _defGrav.direction;
                    _type_data.SetGravity(_gamt, _gdir);
                    break;
                    
                case "colorMix": var _colorMix = _import_data.colorMix; _type_data.SetColorMix(_colorMix); break;
                    
                case "colorRgb":
                    var _colorRgb = _import_data.colorRgb;
                    var _rmin = struct_get(_colorRgb, "rmin");
                    var _rmax = struct_get(_colorRgb, "rmax");
                    _rmin ??= _rmax; _rmax ??= _rmin; //<---if only one of the values exist, the other value defaults to that
                    if(_rmin == undefined && _rmax == undefined){Error("colorRgb needs at least one of the two values 'rmin' or 'rmax' defined.");}
                    
                    var _gmin = struct_get(_colorRgb, "gmin");
                    var _gmax = struct_get(_colorRgb, "gmax");
                    _gmin ??= _gmax; _gmax ??= _gmin;
                    if(_gmin == undefined && _gmax == undefined){Error("colorRgb needs at least one of the two values 'gmin' or 'gmax' defined.");}
                    
                    var _bmin = struct_get(_colorRgb, "bmin");
                    var _bmax = struct_get(_colorRgb, "bmax");
                    _bmin ??= _bmax; _bmax ??= _bmin;
                    if(_bmin == undefined && _bmax == undefined){Error("colorRgb needs at least one of the two values 'bmin' or 'bmax' defined.");}
                    
                    _type_data.SetColorRgb(_rmin, _rmax, _gmin, _gmax, _bmin, _bmax);
                    break;
                    
                case "colorHsv":
                    var _colorHsv = _import_data.colorHsv;
                    var _hmin = struct_get(_colorHsv, "hmin");
                    var _hmax = struct_get(_colorHsv, "hmax");
                    _hmin ??= _hmax; _hmax ??= _hmin; //<---if only one of the values exist, the other value defaults to that
                    if(_hmin == undefined && _hmax == undefined){Error("colorHsv needs at least one of the two values 'hmin' or 'hmax' defined.");}
                    
                    var _smin = struct_get(_colorHsv, "smin");
                    var _smax = struct_get(_colorHsv, "smax");
                    _smin ??= _smax; _smax ??= _smin;
                    if(_smin == undefined && _smax == undefined){Error("colorHsv needs at least one of the two values 'smin' or 'smax' defined.");}
                    
                    var _vmin = struct_get(_colorHsv, "vmin");
                    var _vmax = struct_get(_colorHsv, "vmax");
                    _vmin ??= _vmax; _vmax ??= _vmin;
                    if(_vmin == undefined && _vmax == undefined){Error("colorHsv needs at least one of the two values 'vmin' or 'vmax' defined.");}
                    
                    _type_data.SetColorHsv(_hmin, _hmax, _smin, _smax, _vmin, _vmax);
                    break;
                    
                case "color": var _color = _import_data.color; _type_data.SetColor(_color); break;
                    
                case "alpha": var _alpha = _import_data.alpha; _type_data.SetAlpha(_alpha); break;
                    
                case "blend": var _blend = _import_data.blend; _type_data.SetBlend(_blend); break;
                    
                case "life":
                    var _life = _import_data.life;
                    var _defLife = _type_data.GetLife();
                    var _min = struct_get(_life, "min") ?? _defLife.min;
                    var _max = struct_get(_life, "max") ?? _defLife.max;
                    _type_data.SetLife(_min, _max);
                    break;
                    
                case "step":
                    var _step = _import_data.step;
                    var _defStep = _type_data.GetStep();
                    var _number = struct_get(_step, "number") ?? _defStep.number;
                    var _type = struct_get(_step, "type") ?? _defStep.type;
                    _type_data.SetStep(_number, _type);
                    break;
                    
                case "death":
                    var _death = _import_data.death;
                    var _defDeath = _type_data.GetDeath();
                    var _number = struct_get(_death, "number") ?? _defDeath.number;
                    var _type = struct_get(_death, "type") ?? _defDeath.type;
                    _type_data.SetDeath(_number, _type);
                    break;
                    
                default: Log($"Part type property: {_name} is not supported!");
            }
        }
        
    }
    
    static ConvertGmlPartAssetToPollenStruct = function(_asset, _pollen_struct, _ignore_emitter_list = false){
        
        _pollen_struct.__template = _asset; //<----This ensures that templates are only loaded once
        
        //--- SYSTEM ---//
        var _data = particle_get_info(_asset);
        var _originX = struct_get(_data, "xorigin") ?? 0;
        var _originY = struct_get(_data, "yorigin") ?? 0;
        var _globalSpace = struct_get(_data, "global_space") ?? false;
        var _drawOrder = struct_get(_data, "oldtonew") ?? false;
        var _gmEmitters = struct_get(_data, "emitters") ?? [];
        
        _pollen_struct
            .SetPosition(_originX, _originY)
            .SetGlobalSpace(_globalSpace)
            .SetDrawOrder(_drawOrder);
            
        //This will be an optimization in case we detect in the JSON that the emitterList is being overridden by the new system
        if(_ignore_emitter_list){Log($"Successfully converted Gml part asset: {_pollen_struct.GetTag()}!"); return;}
        
        //--- EMITTERS ---//
        var _typeList = [];
        var _emitterList = [];
        var _numEmitters = array_length(_gmEmitters);
        var _iEmitter = -1;
        repeat(_numEmitters){
            _iEmitter++;
            var _emitter = _gmEmitters[_iEmitter];
            var _partType = struct_get(_emitter, "parttype");
            if(_partType != undefined){array_push(_typeList, _partType);}
            
            var _enabled = struct_get(_emitter, "enabled") ?? true;
            var _shape = struct_get(_emitter, "shape") ?? ps_shape_ellipse;
            var _distr = struct_get(_emitter, "distribution") ?? ps_distr_linear;
            var _relative = struct_get(_emitter, "relative") ?? false;
            var _number = struct_get(_emitter, "number") ?? 1;
            
            var _xMin = struct_get(_emitter, "xmin") ?? 0, _xMax = struct_get(_emitter, "xmax") ?? 0;
            var _yMin = struct_get(_emitter, "ymin") ?? 0, _yMax = struct_get(_emitter, "ymax") ?? 0;
            var _width = _xMax - _xMin;
            var _height = _yMax - _yMin;
            var _offsetX = _xMin + 0.5*_width;
            var _offsetY = _yMin + 0.5*_height;
            
            var _delayMin = struct_get(_emitter, "delay_min") ?? 0;
            var _delayMax = struct_get(_emitter, "delay_max") ?? 0;
            var _delayUnit = struct_get(_emitter, "delay_unit") ?? time_source_units_frames;
            var _intervalMin = struct_get(_emitter, "interval_min") ?? 0;
            var _intervalMax = struct_get(_emitter, "interval_max") ?? 0;
            var _intervalUnit = struct_get(_emitter, "interval_unit") ?? time_source_units_frames;
    
            var _pEmitter = new PfxEmitter(_pollen_struct);
            _pEmitter
                .SetEnabled(_enabled)
                .SetShape(_shape)
                .SetDistr(_distr)
                .SetRelative(_relative)
                .SetNumber(_number)
                .SetSize(_width, _height)
                .SetOffset(_offsetX, _offsetY)
                .SetDelay({min: _delayMin, max: _delayMax, unit: _delayUnit})
                .SetInterval({min: _intervalMin, max: _intervalMax, unit: _intervalUnit});
                
            array_push(_emitterList, _pEmitter);
        }
        
        _pollen_struct.SetEmitterList(_emitterList);
        
        //--- TYPES ---//
        var _numTypes = array_length(_typeList);
        var _iType = -1;
        repeat(_numTypes){
            _iType++;
            var _type = _typeList[_iType];
            var _tag = $"{_pollen_struct.GetTag()}_type_{_iType}";
            
            var _shape = struct_get(_type, "shape");
            var _sprite = struct_get(_type, "sprite");
            var _frame = struct_get(_type, "frame") ?? 0;
            var _animate = struct_get(_type, "animate") ?? false;
            var _stretch = struct_get(_type, "stretch") ?? false;
            var _randomImg = struct_get(_type, "random") ?? false;
        
            // Size
            var _sizeXMin = struct_get(_type, "size_xmin") ?? 0
            var _sizeXMax = struct_get(_type, "size_xmax") ?? 0
            var _sizeXIncr = struct_get(_type, "size_xincr") ?? 0
            var _sizeXWiggle = struct_get(_type, "size_xwiggle") ?? 0 
        
            var _sizeYMin = struct_get(_type, "size_ymin") ?? 0
            var _sizeYMax = struct_get(_type, "size_ymax") ?? 0
            var _sizeYIncr = struct_get(_type, "size_yincr") ?? 0
            var _sizeYWiggle = struct_get(_type, "size_ywiggle") ?? 0 
        
            // Scale
            var _scaleX = struct_get(_type, "xscale") ?? 1;
            var _scaleY = struct_get(_type, "yscale") ?? 1;
        
            // Speed
            var _spdMin = struct_get(_type, "speed_min") ?? 1;
            var _spdMax = struct_get(_type, "speed_max") ?? 1;
            var _spdIncr = struct_get(_type, "speed_incr") ?? 0;
            var _spdWiggle = struct_get(_type, "speed_wiggle") ?? 0;
        
            // Direction
            var _dirMin = struct_get(_type, "dir_min") ?? 0;
            var _dirMax = struct_get(_type, "dir_max") ?? 0;
            var _dirIncr = struct_get(_type, "dir_incr") ?? 0;
            var _dirWiggle = struct_get(_type, "dir_wiggle") ?? 0;
        
            // Gravity
            var _gravAmt = struct_get(_type, "grav_amount") ?? 0;
            var _gravDir = struct_get(_type, "grav_dir") ?? 270;
        
            // Orientation
            var _angMin = struct_get(_type, "ang_min") ?? 0;
            var _angMax = struct_get(_type, "ang_max") ?? 0;
            var _angIncr = struct_get(_type, "ang_incr") ?? 0;
            var _angWiggle = struct_get(_type, "ang_wiggle") ?? 0;
            var _angRel = struct_get(_type, "ang_relative") ?? false;
        
            // Color (standard 1/2/3), Mix, RGB, HSV
            var _color1 = struct_get(_type, "color1") ?? c_white;
            var _color2 = struct_get(_type, "color2");
            var _color3 = struct_get(_type, "color3");
            var _colArr = [_color1];
            
            if(_color2 != undefined){array_push(_colArr, _color2);}
            if(_color3 != undefined){array_push(_colArr, _color3);}
        
            // Alpha (1/2/3)
            var _alpha1   = struct_get(_type, "alpha1") ?? 1;
            var _alpha2   = struct_get(_type, "alpha2");
            var _alpha3   = struct_get(_type, "alpha3");
            var _alphaArr = [_alpha1];
            
            if(_alpha2 != undefined){array_push(_alphaArr, _alpha2);}
            if(_alpha3 != undefined){array_push(_alphaArr, _alpha3);}
        
            // Blend
            var _additive = struct_get(_type, "additive") ?? false;
        
            // Life
            var _lifeMin = struct_get(_type, "life_min") ?? 100;
            var _lifeMax = struct_get(_type, "life_max") ?? 100;
        
            // Sub-particle Step/Death
            var _stepNum = struct_get(_type, "step_number") ?? 0;
            var _stepType = struct_get(_type, "step_type");
            var _deathNum = struct_get(_type, "death_number") ?? 0;
            var _deathType = struct_get(_type, "death_type");
        
            // Create Pollen type and apply all properties
            var _pType = new PfxType(_tag);
        
            // Shape / Sprite
            if (_shape != undefined && _shape != -1){_pType.SetShape(_shape);}
            if (_sprite != -1){_pType.SetSprite(_sprite, _frame, _animate, _stretch, _randomImg);}
        
            // Size (uniform), SizeX, SizeY (apply specific axes only if any field exists)
            if(_sizeXMin == _sizeYMin && _sizeXMax == _sizeYMax && _sizeXIncr == _sizeYIncr && _sizeXWiggle == _sizeYWiggle){
                _pType.SetSize(_sizeXMin, _sizeXMax, _sizeXIncr, _sizeXWiggle);   
            }
            else {
                _pType.SetSizeX(_sizeXMin, _sizeXMax, _sizeXIncr, _sizeXWiggle); 
                _pType.SetSizeY(_sizeYMin, _sizeYMax, _sizeYIncr, _sizeYWiggle); 
            }
        
            // Scale
            _pType.SetScale(_scaleX, _scaleY);
        
            // Kinematics
            _pType
                .SetSpeed(_spdMin, _spdMax, _spdIncr, _spdWiggle)
                .SetDirection(_dirMin, _dirMax, _dirIncr, _dirWiggle)
                .SetGravity(_gravAmt, _gravDir)
                .SetOrientation(_angMin, _angMax, _angIncr, _angWiggle, _angRel);
        
            // Color
            _pType
                .SetColor(_colArr)
                .SetAlpha(_alphaArr)
                .SetBlend(_additive);
        
            // Life
            _pType.SetLife(_lifeMin, _lifeMax);
        
            // Sub-particle generation
            if (_stepType != -1 && _stepNum != 0){_pType.SetStep(_stepNum, _stepType);}
            if (_deathType != -1 && _deathNum != 0){_pType.SetDeath(_deathNum, _deathType);}
            
            _emitterList[_iType].SetType(_pType);
        }
        
        Log($"Successfully converted Gml part asset: {_pollen_struct.GetTag()}!");
    }
    

#endregion    
//======================================================================================================================
#region ~ DEBUG ~
//======================================================================================================================
    
    static Log = function(_message){show_debug_message("Pollen -> " + _message);}
    static Warn = function(_message){show_debug_message("Pollen -> Warning! " + _message);}
    static Error = function(_message){show_error("Pollen -> Error! " + _message, true);}


#endregion    
//======================================================================================================================
#region ~ SETUP ~
//======================================================================================================================

} //<---DON'T DELETE THIS!!!

//We only need the static vars in Pollen so we instantiate Pollen to set them up, then delete the actual instance since we don't need it.
var _initPollen = new Pollen(); 
delete _initPollen;
Pollen.ImportPfx(global.pollen_config_pfx); //<---Do not rename any files or this might not work since it requires the other scripts to be initialized first!!!
Pollen.Log("Ready!");


//======================================================================================================================